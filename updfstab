#!/bin/sh
# name: /etc/dev.d/default/updfstab.dev
# version: 13
# purpose: automatic handling of /etc/fstab for usb_storage devices under kernel 2.6 with udev
# This script is automatically called by udevd at each plug/unplug event of an usb device.
# It adds a line in /etc/fstab for each usb_storage device found,
# with a pretty name as mountpoint. (based on label or info read from /sys)
# it takes three environment variables as input : ACTION, DEVNAME and DEVPATH
# These variables are provided by udevd
##################################################################
# Copyright (C) 2004 Christophe Combelles (ccomb@free.fr)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
##################################################################

# to debug this script, uncomment the next line and see /tmp/updfstab.debug after execution
#DEBUG=1

# exit immediately if /usr/bin/ is not yet available (during boot if /usr is a separate partition)
/bin/ls -d /usr/bin/ >/dev/null 2>&1 || exit

DEBUGOUT=/tmp/updfstab.debug.$$
if [ "$DEBUG" = "1" -a -z "$2" ]; then
  echo "executing $0 $@" > $DEBUGOUT
  echo "with the following environment variables:" >> $DEBUGOUT
  env >> $DEBUGOUT
  echo "----" >> $DEBUGOUT
  sh -x $0 $@ debug >> $DEBUGOUT 2>&1
  exit
fi

# we only manage block devices
if [ "$1" != "block" ]; then exit; fi

# we only manage usb_storage devices
if [ "$ACTION" = "add" ]; then
  device="`ls /sys$DEVPATH/../device/../../../ 2> /dev/NULL | grep ':' | head -1`"
  if [ -z "$device" -o ! -e /sys/bus/usb/drivers/usb-storage/$device ]; then exit; fi
fi

# lockfile used when modifying /etc/fstab
LOCKFILE=/var/run/updfstab.dev.fstab
# remove the lockfile when exiting
cleanquit() {
rm -f $LOCKFILE; exit
}
trap cleanquit INT
trap cleanquit TERM
trap cleanquit QUIT
trap cleanquit HUP

# write a lockfile to avoid simultaneous modifications of fstab by parallel executions
# or simultaneous access to the device
lockfile -1 -l 5 -s 5 $LOCKFILE

# functions for syslog
LOGGER="logger -t `basename $0`[$$] -p user.notice"
write_syslog () {
  echo ${@} | $LOGGER
}

# be sure the drivers are loaded
/sbin/modprobe -q usb_storage
/sbin/modprobe -q vfat

# create the FSH required /media directory
# See: http://www.pathname.com/fhs/pub/fhs-2.3.html#MEDIAMOUNTPOINT
MNT=media
if [ ! -d /$MNT ]; then
  mkdir /$MNT
  write_syslog "Created the /$MNT directory"
  if [ "$MNT" = "media" ]; then
    write_syslog "It is required by FHS standard"
    write_syslog "Please read: http://www.pathname.com/fhs/pub/fhs-2.3.html#MEDIAMOUNTPOINT"
  fi
fi

# we need DEVPATH, DEVNAME and ACTION, so we warn the user that executes this script by hand
if [ -z "$DEVPATH" -a -z "$DEVNAME" -a -z "$ACTION" ]; then
  echo
  echo "This script must be called by udevd because it needs the following environment variables: DEVPATH, DEVNAME, ACTION"
  echo "So you must copy this script as /etc/dev.d/default/updfstab-2.6.dev and set it executable"
  echo "See: http://www.kernel.org/pub/linux/utils/kernel/hotplug/RFC-dev.d"
  echo
  exit
fi

# if $DEVPATH/device exists, we are a device, not a partition, so exit
if [ -d /sys${DEVPATH}/device ]; then exit; fi


# remove the fstab entry and the mountpoint if they already exist
if grep -q "^$DEVNAME\ .*\#updfstab$" /etc/fstab; then
  # get the mount point from fstab
  mntpoint=`grep "^$DEVNAME\ .*\#updfstab$" /etc/fstab | sed "s/.* \/${MNT}/\/${MNT}/g; s/ .*//g"`
  # if we want to unplug a mounted device, we are a fool, so limit the damage.
  if mount | grep -q "^$DEVNAME\ "; then
    # if the mountpoint is used by famd, and we kill it, we'll need to restart it
    if fuser -v USBStorageAdapter | grep -q " famd$"; then RESTARTFAMD=1; fi
    fuser -k $mntpoint
    fuser -k -9 $mntpoint
    umount $mntpoint
    FAM=/etc/init.d/fam
    if [ "$RESTARTFAMD" = "1" -a -x $FAM ]; then $FAM restart; fi
  fi
  # remove the mount point
  if [ ! -z "$mntpoint" -a -d $mntpoint ]; then rmdir $mntpoint; fi
  write_syslog "Deleted mountpoint $mntpoint"

  # remove the fstab entry corresponding to the device
  TMP=/etc/fstab.updated$$
  grep -v  "^$DEVNAME\ .*\#updfstab$" /etc/fstab > $TMP
  if diff /etc/fstab $TMP >/dev/null 2>&1; then
    rm -f $TMP
  else
    if [ -s /etc/fstab.updated$$ ]; then
      cat $TMP > /etc/fstab
      write_syslog "Removed $DEVNAME from fstab"
    fi
    rm -f $TMP
  fi
fi

# if the current device is being added
if [ "$ACTION" = "add" ]; then
  # get partition information
  FILETYPE="`file -s $DEVNAME`"
  label=`echo "$FILETYPE" | grep "label:" | sed 's/.*label:\ *"//; s/".*//; s/[ \/]//g'`
  partition="/sys${DEVPATH}/../device/../../.."
  if [ -e $partition/product ]; then product="`cat $partition/product | sed 's/[ \/]//g'`"; fi
  if [ -e $partition/manufacturer ]; then manufacturer="`cat $partition/manufacturer | sed 's/[ \/]//g'`"; fi

  # if we are an extended partition, just exit
  if echo "$FILETYPE" | grep -q "extended partition table"; then cleanquit; fi

  # handle XFS ('file' doesn't print label)
  xfs=`echo "$FILETYPE" | grep "XFS"`
  if [ -z "${label}" -a ! -z "${xfs}" -a -x "`which xfs_admin`" ]; then
    label=`xfs_admin -l $DEVNAME | sed 's/.*label\ =\ *"\+//; s/"\+$//; s/[ \/]//g'`
  fi

  # handle EXT2/3
  ext=`echo "$FILETYPE" | grep "ext[23]"`
  if [ ! -z "${ext}" -a -z "${label}" -a -x "`which e2label`" ]; then
    label=`e2label $DEVNAME | sed 's/[ \/]//g'`
  fi

  # build a mountpoint name = label, else product, else manufacturer, else usb-disk
  if [ ! -z "${label}" ]; then mntpoint="/$MNT/${label}"
  else if [ ! -z "${product}" ]; then mntpoint="/$MNT/${product}"
     else if [ ! -z "${manufacturer}" ]; then mntpoint="/$MNT/${manufacturer}"
          else mntpoint="/$MNT/usb-disk"
  fi;  fi;  fi

  # if we are not the partition number 1, append the partition number
#  partnumber=`basename ${DEVPATH} | sed "s/\`basename \\\`dirname ${DEVPATH}\\\`\`//g"`
#  if [ ! -z "$partnumber" -a "$partnumber" != "1" ]; then
#    mntpoint="${mntpoint}-part${partnumber}"
#  fi


  # if the mount point is already used in fstab, append a number
  count=`grep -cE " ${mntpoint}[_]?[[:digit:]]* " /etc/fstab`
  if [ $count -ne 0 ]; then mntpoint="${mntpoint}_$((count+1))"; fi

  # create the mountpoint and the fstab entry if they don't exist
  if [ ! -d "${mntpoint}" ]; then
    mkdir ${mntpoint}
    write_syslog "Created mountpoint ${mntpoint}"
  fi
  # if we are a FAT or NTFS, set the charset to utf8
  if echo $FILETYPE | grep -q "FAT"; then IOCHARSET=",iocharset=utf8"; fi
  if echo $FILETYPE | grep -q "NTFS"; then IOCHARSET=",iocharset=utf8"; fi
  FSTABLINE="$DEVNAME $mntpoint auto user,noauto,noatime,rw${IOCHARSET} 0 0 #updfstab"
  echo "$FSTABLINE" >> /etc/fstab
  write_syslog "Added $DEVNAME to fstab"
fi

# remove the lockfile
rm -f $LOCKFILE

